{"searchDocs":[{"title":"Introduction","type":0,"sectionRef":"#","url":"/feces/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/feces/docs/intro#installation","content":" Currently only available on pesde. ","version":"Next","tagName":"h2"},{"title":"Hooks","type":0,"sectionRef":"#","url":"/feces/docs/hooks","content":"","keywords":"","version":"Next"},{"title":"Hook Methods​","type":1,"pageTitle":"Hooks","url":"/feces/docs/hooks#hook-methods","content":" added()​  Hooks onto when a new entity is replicated to the world, not for new components. The added callback is called after the first component value reveived is set to a newly replicated entity. This is because there has to be at least one replicating component under an entity for it to be added through feces.  changed()​  Hooks onto when a component value is changed in the world. Called before the component's new value is set in the world. This means that you can get whether the entity has the component or not, and the previous value of the component.  This also allows you to check for component deletions, values being set to nil, and compare previous and current values. The callback will pass in nil to value if the component was removed or the value was set to nil.  To know for sure if a component was removed and not set to nil, you would need to use the context of your own game since the hooks aren't given that information. (Maybe we'll add a removed() hook in the future)  feces.changed(function(entity, component, value) local had = world:has(entity, component) if not had then print(&quot;component added&quot;, component) return end local previous = world:get(entity, component) if value == nil then print(&quot;component removed or set to nil&quot;, component) return end print(&quot;component changed&quot;, component, previous, &quot;-&gt;&quot;, value) end)   deleted()​  Hooks onto when an entity is deleted in the world. This is called before the entity is deleted, allowing you to get the component values and cleanup, fairly straightforward. ","version":"Next","tagName":"h2"},{"title":"Setup","type":0,"sectionRef":"#","url":"/feces/docs/setup","content":"","keywords":"","version":"Next"},{"title":"Simple​","type":1,"pageTitle":"Setup","url":"/feces/docs/setup#simple","content":" This option reduces code written and tools needed. In most cases, developers don't need to implement anything more complex than this unless they will be using feces to replicate large amounts of data often.  if RunService:IsServer() then requestFullPacket.OnServerEvent:Connect(function(player) remote:FireClient(player, full()) end) else requestFullpacket:FireServer() remote.OnClientEvent:Connect(function(data) apply(data) end) end local function replicate() local changes, deleted = delta() if not next(changes) and not next(deleted) then return end for player, packet in group(changes, deleted) do remote:FireClient(player, packet) end end  ","version":"Next","tagName":"h2"},{"title":"feces","type":0,"sectionRef":"#","url":"/feces/api/feces","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"feces","url":"/feces/api/feces#types","content":" ","version":null,"tagName":"h2"},{"title":"changes​","type":1,"pageTitle":"feces","url":"/feces/api/feces#changes","content":"&lt;/&gt; type changes = {[Component]: {[Player ]: { value: {[Entity]: any}, special: {[Entity]: deleteValue | nilValue} }}} How changes are represented and returned from delta().  ","version":null,"tagName":"h3"},{"title":"deletes​","type":1,"pageTitle":"feces","url":"/feces/api/feces#deletes","content":"&lt;/&gt; type deletes = {[Player ]: {Entity}} How deleted entities are represented.  ","version":null,"tagName":"h3"},{"title":"applyable​","type":1,"pageTitle":"feces","url":"/feces/api/feces#applyable","content":"&lt;/&gt; type applyable = {[Component]: { value: {[Entity]: any}, special: {[Entity]: deleteValue | nilValue} }} &amp; {__d: {Entity}} Funkier type for how applyable changes should be formated. ","version":null,"tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"feces","url":"/feces/api/feces#properties","content":" ","version":null,"tagName":"h2"},{"title":"replicated​","type":1,"pageTitle":"feces","url":"/feces/api/feces#replicated","content":"&lt;/&gt; feces.replicated: Component The feces library for replicating jecs entities and components. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"feces","url":"/feces/api/feces#functions","content":" ","version":null,"tagName":"h2"},{"title":"apply​","type":1,"pageTitle":"feces","url":"/feces/api/feces#apply","content":"&lt;/&gt; feces.apply(delta: applyable) → () Applies changes to the world by taking in the applyable type and editing the world. feces.apply({ [someComponent] = { [someForeignEntity] = someValue, } })   ","version":null,"tagName":"h3"},{"title":"delta​","type":1,"pageTitle":"feces","url":"/feces/api/feces#delta","content":"&lt;/&gt; feces.delta() → ( changes, deletes ) Gets the world changes from the last time it was called. local changedComponents, deletedEntities = feces.delta() -- ... replicate however you'd like or see the examples [here](/docs/setup)   ","version":null,"tagName":"h3"},{"title":"group​","type":1,"pageTitle":"feces","url":"/feces/api/feces#group","content":"&lt;/&gt; feces.group( changes: changes, deleted: deletes? ) → {[Player ]: applyable} Reformats the results of delta() into an easier format to replicate. Not optimal, but recommended if performance of feces-replicated entities is not a concern. local dataByPlayer = feces.group(feces.delta()) for player, packet in dataByPlayer do someRemote:FireClient(player, packet) end -- see more of this example [here](/docs/setup#simple)   ","version":null,"tagName":"h3"},{"title":"full​","type":1,"pageTitle":"feces","url":"/feces/api/feces#full","content":"&lt;/&gt; feces.full() → applyable Gets all the currently replicating component and entity values. TIP This is useful for providing payloads to new players when they first join a server. local changedComponents = feces.full() -- ... replicate however you'd like or see the examples [here](/docs/setup)   ","version":null,"tagName":"h3"},{"title":"added​","type":1,"pageTitle":"feces","url":"/feces/api/feces#added","content":"&lt;/&gt; feces.added(callback: (Entity) → nil) → () Adds a callback for when an entity is added to the world through apply(). Called after a (not all) component value is set to a newly replicated entity. feces.added(function(entity) print(&quot;entity added&quot;, entity) end) See how you might use this here.  ","version":null,"tagName":"h3"},{"title":"changed​","type":1,"pageTitle":"feces","url":"/feces/api/feces#changed","content":"&lt;/&gt; feces.changed(callback: ( Entity, Component ) → nil) → () Adds a callback for when a component value is changed in the world through apply(). Called before the component in question is changed, deleted, or set to nil. feces.changed(function(entity, component, value) local previous = world:get(entity, component) print(&quot;component changed&quot;, component, previous, &quot;-&gt;&quot;, value) end) See how you might use this here.  ","version":null,"tagName":"h3"},{"title":"deleted​","type":1,"pageTitle":"feces","url":"/feces/api/feces#deleted","content":"&lt;/&gt; feces.deleted(callback: (Entity) → nil) → () Adds a callback for when an entity is deleted in the world through apply(). Called before the entity in question is deleted, allowing hooks to get component values and cleanup. feces.deleted(function(entity) print(&quot;entity deleted&quot;, entity) end) See how you might use this here. ","version":null,"tagName":"h3"},{"title":"Advanced Setup","type":0,"sectionRef":"#","url":"/feces/docs/advanced-setup","content":"Advanced Setup This example will use Blink but the same concepts can likely be applied to any other compiled networking library. In our blink file events like requestFullPacket and entityDeleted are -- network.blink event requestFullPacket { from: Client, type: Reliable, call: SingleAsync } event entityDeleted { from: Server, type: Reliable, call: SingleAsync, data: u16[] } type Entity = u16 map EntityMap&lt;T&gt; = { [Entity]: T } enum SpecialChange = { __n, __d } struct ComponentPacket&lt;T&gt; { value: EntityMap&lt;T&gt;, special: EntityMap&lt;SpecialChange&gt; } event component { from: Server, type: Reliable, call: SingleAsync, data: (Entity, ComponentPacket&lt;unknown&gt;) } event componentTransform { from: Server, type: Reliable, call: SingleAsync, data: ComponentPacket&lt;CFrame&gt; } -- ... You'd have to make a new event to properly optimize replicating each component This is very close to actual code we use at killergg for optimally replicating commonly used components. It might be verbose, but it gets the job done. local function fire(network, player, component, entities) local remote = network[`component{getNameFromComponent(component)}`] if remote == nil then network.component.fire(player, component, entities) return end remote.fire(player, entities) end local function replicate() local network = require(ReplicatedStorage.Blink.Server) local fullPacket = nil for _, player in network.requestFullPacket.iter() do fullPacket = fullPacket or full() for component, data in fullPacket do fire(network, player, component, data) end end local changes, deleted = delta() for component, players in changes do for player, entities in players do fire(network, player, component, entities) end end for player, entities: { number } in deleted do network.entityDeleted.fire(player, entities) end end local function receive() local network = require(ReplicatedStorage.Blink.Client) for _, component, entities in network.component.iter() do apply({ [component] = entities }) end for name, id in Components do local remote = network[`component{getNameFromComponent(name)}`] if not remote then continue end for _, entities in remote.iter() do apply({ [id] = entities }) end end for _, entities in network.entityDeleted.iter() do apply({ __d = entities }) end end ","keywords":"","version":"Next"}],"options":{"id":"default"}}