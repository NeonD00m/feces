"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[845],{7060:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"hooks","title":"Hooks","description":"Hooks allow you to add features tied to the replication process.","source":"@site/docs/hooks.md","sourceDirName":".","slug":"/hooks","permalink":"/feces/docs/hooks","draft":false,"unlisted":false,"editUrl":"https://github.com/NeonD00m/feces/edit/main/docs/hooks.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"defaultSidebar","previous":{"title":"Advanced Setup","permalink":"/feces/docs/advanced-setup"}}');var d=o(4848),s=o(8453);const r={sidebar_position:5},i="Hooks",a={},c=[{value:"Hook Methods",id:"hook-methods",level:2},{value:"<code>added()</code>",id:"added",level:4},{value:"<code>changed()</code>",id:"changed",level:4},{value:"<code>deleted()</code>",id:"deleted",level:4}];function l(e){const n={a:"a",admonition:"admonition",code:"code",div:"div",em:"em",h1:"h1",h2:"h2",h4:"h4",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.header,{children:(0,d.jsx)(n.h1,{id:"hooks",children:"Hooks"})}),"\n",(0,d.jsx)(n.p,{children:"Hooks allow you to add features tied to the replication process."}),"\n",(0,d.jsxs)(n.admonition,{type:"warning",children:[(0,d.jsx)(n.p,{children:"With any of the hook methods:\r\nOnly one callback can be set at a time and calling again will overwrite the previous callback."}),(0,d.jsx)(n.p,{children:"If you'd like a signal or some sort of scheduler please set that up on your own."})]}),"\n",(0,d.jsx)(n.h2,{id:"hook-methods",children:"Hook Methods"}),"\n",(0,d.jsx)(n.h4,{id:"added",children:(0,d.jsx)(n.a,{href:"/api/feces#added",children:(0,d.jsx)(n.code,{children:"added()"})})}),"\n",(0,d.jsxs)(n.p,{children:["Hooks onto when a new ",(0,d.jsx)(n.strong,{children:"entity"})," is replicated to the world, not for new components.\r\nThe added callback is called ",(0,d.jsx)(n.em,{children:"after"})," the first component value reveived is set to\r\na newly replicated entity. This is because there has to be at least one replicating\r\ncomponent under an entity for it to be added through feces."]}),"\n",(0,d.jsx)(n.h4,{id:"changed",children:(0,d.jsx)(n.a,{href:"/api/feces#changed",children:(0,d.jsx)(n.code,{children:"changed()"})})}),"\n",(0,d.jsxs)(n.p,{children:["Hooks onto when a ",(0,d.jsx)(n.strong,{children:"component"})," value is changed in the world. Called ",(0,d.jsx)(n.em,{children:"before"})," the component's new value is set in the world. This means that you can get whether the entity has the component or not, and the previous value of the component."]}),"\n",(0,d.jsxs)(n.p,{children:["This also allows you to check for component deletions, values being set to ",(0,d.jsx)(n.code,{children:"nil"}),", and compare previous and current values. The callback will pass in ",(0,d.jsx)(n.code,{children:"nil"})," to ",(0,d.jsx)(n.code,{children:"value"})," if the component was removed or the value was set to nil."]}),"\n",(0,d.jsx)(n.div,{children:(0,d.jsx)(n.p,{children:"To know for sure if a component was removed and not set to nil, you would need to use the\r\ncontext of your own game since the hooks aren't given that information.\r\n(Maybe we'll add a removed() hook in the future)"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-lua",children:'feces.changed(function(entity, component, value)\r\n    local had = world:has(entity, component)\r\n    if not had then\r\n        print("component added", component)\r\n        return\r\n    end\r\n    local previous = world:get(entity, component)\r\n    if value == nil then\r\n        print("component removed or set to nil", component)\r\n        return\r\n    end\r\n    print("component changed", component, previous, "->", value)\r\nend)\n'})}),"\n",(0,d.jsx)(n.h4,{id:"deleted",children:(0,d.jsx)(n.a,{href:"/api/feces#deleted",children:(0,d.jsx)(n.code,{children:"deleted()"})})}),"\n",(0,d.jsxs)(n.p,{children:["Hooks onto when an ",(0,d.jsx)(n.strong,{children:"entity"})," is deleted in the world. This is called ",(0,d.jsx)(n.em,{children:"before"})," the entity is deleted, allowing you to get the component values and cleanup, fairly straightforward."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(l,{...e})}):l(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>i});var t=o(6540);const d={},s=t.createContext(d);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);